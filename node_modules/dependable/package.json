{
  "name": "dependable",
  "version": "0.2.5",
  "main": "index.js",
  "author": {
    "name": "Sean Hess"
  },
  "contributors": [
    {
      "name": "Jamison Dance",
      "email": "jergason@gmail.com",
      "url": "http://jamisondance.com"
    }
  ],
  "repository": {
    "url": "git@github.com:idottv/dependable.git"
  },
  "scripts": {
    "test": "node_modules/.bin/mocha -R spec --compilers coffee:coffee-script test/*",
    "prepublish": "node_modules/.bin/coffee -c index.coffee"
  },
  "license": "BSD",
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.3.0",
    "coffee-script": "~1.3.3"
  },
  "readme": "# Dependable\n\nA minimalist dependency injection framework for javascript (fully tested for node.js)\n\n## Goals\n\n1. Allow creation of modules that can be passed dependencies instead of requiring them. \n2. Simple bootstrapping, minimal footprint\n3. Automatic\n\n## Documentation\n\n### What is Dependency Injection\nIn CommonJS, modules are normally defined like one of the following\n\n    exports.hello = -> \"hello world\"\n\n    module.exports =\n      hello: \"hello world\"\n\n\nIf you have a dependency, you normally just require it. The `greetings` module needs some config to work. \n\n    Greetings = require \"greetings\"\n    greetings = new Greetings(\"en\")\n\n    module.exports = ->\n      hello: -> greetings.hello(\"world\")\n\nInstead of requiring it, and setting the config inside our module, we can require that a pre-configured greetings instance be passed in to our function.\n\n    module.exports = (greetings) ->\n      hello: -> greetings.hello(\"world\")\n\nThis is \"Dependency Injection\". `greetings` is a dependency of our module. Its dependencies are \"injected\", meaning they are handed to us by whoever uses our module instead of us reaching out for them. \n\n### Why Dependency Injection?\n\nIf you ever need to change your config options, such as when testing, or to hit different layers of a service, it is easier to have a pre-configured object passed in instead of creating it yourself.\n\nYour module is a little less coupled to its dependency\n\nYou can pass in mock or alternate versions of a module if you want\n\n### This is Annoying\n\nIt is hard to remember how to construct and configure the dependencies when you want to use your module. This should be automatic.  Here is an example\n\nrobot.coffee\n\n    module.exports = (greetings) ->\n      hello: -> greetings.hello(\"world\")\n\ngreetings.coffee\n\n    module.exports = (language) ->\n      ...\n\napp.coffee\n\n    # you have to do this in every file you want to use robot\n    Greetings = require \"greetings\"\n    greetings = Greetings(\"en\")\n\n    Robot = require \"robot\"\n    robot = Robot greetings\n\n    itsAliiiive = -> \n      console.log robot.hello()\n\n\n*This gets much worse* when your dependencies have dependencies of their own. You have to remember in which order to configure them so you can pass them into each other. \n\n### Using Dependenable\n\nDependable automates this process. In the following example, you don't need to register the modules in order, or do it more than once (it will work for dependencies of dependencies)\n\n\nrobot.coffee\n\n    module.exports = (greetings) ->\n      hello: -> greetings.hello(\"world\")\n\ngreetings.coffee\n\n    module.exports = (language) ->\n      ...\n\napp.coffee\n\n    # create the container, you only have to do this once.\n    container = require(\"dependable\").container\n    deps = container()\n    deps.register \"greetings\", require(\"greetings\")\n    deps.register \"robot\", require(\"robot\")\n\n    robot = deps.get \"robot\"\n\n    itsAliiiive = -> \n      console.log robot.hello()\n\n### Using Dependable's Load\n\nYou can load files or directories instead of registering by hand. See [Reference](#reference)\n \n### Overriding Dependencies for Testing\n\nWhen testing, you usually want most dependencies loaded normally, but to mock others. You can use overrides for this. In the example below, `User` depends on `Friends.getInfo` for it's `getFriends` call. By setting `Friends` to `MockFriends` we can stub the dependency, but any other dependencies `User` has will be passed in normally.\n\n    # boostrap.coffee\n    deps = container()\n    deps.register \"Friends\", require('./Friends')\n    deps.register \"User\", require('./User')\n\n    # test.coffee\n    describe 'User', ->\n      it 'should get friends plus info', (done) ->\n\n        MockFriends =\n          getInfo: (id, cb) -> cb null, {some:\"info\"}\n\n        User = deps.get \"User\", {Friends: MockFriends}\n        User.getFriends \"userId\", (err, friends) ->\n          # assertions\n          done()\n\n## Reference\n\n`container.register(name, function)` - registers a dependency by name. `function` can be a function that takes dependencies and returns anything, or an object itself with no dependencies.\n\n`container.register(hash)` - registers a hash of names and dependencies. Useful for config.\n\n`container.load(fileOrFolder)` - registers a file, using its file name as the name, or all files in a folder. Does not follow sub directories\n\n`container.get(name, overrides = {})` - returns a module by name, with all dependencies injected. If you specify overrides, the dependency will be given those overrides instead of those registerd. \n\n`container.resolve([overrides,] cb)` - calls cb like a dependency function, injecting any dependencies found in the signature\n\n    deps.resolve (User) ->\n      # do something with User\n\n\n",
  "readmeFilename": "README.md",
  "description": "A minimalist dependency injection framework for javascript (fully tested for node.js)",
  "bugs": {
    "url": "https://github.com/idottv/dependable/issues"
  },
  "_id": "dependable@0.2.5",
  "_from": "dependable@0.2.5"
}
